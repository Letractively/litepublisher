classname = tcontentfilter
parent = tevents
source = lib/contentfilter.class.php


Специальный класс для конвертирования текста в html в записях и комментариях. LitePublisher устроен таким образом, что хранит исходный текст и отфильтрованный конечный html записей, комментариев, меню. Преобразование между исходным текстом и конечным html как раз делает этот класс. Соответственно очень много плагинов встраиваются в цепочки таких фильтров, например markdown, wiki, система документации, плеер youtube, короткие коды, внешние ссылки, tidy и так далее. Все эти плагины подписываются (другими словами обрабатывают) события этого класса. Фильтрация текста как правило происходит один раз (или после изменения исходного текста) и ее результаты используются. Чтобы перефильтровать все записи (например при инсталляции плагина внешних ссылок) есть специальный механизм litepublisher - номер ревизии, смотрите [[tposts::addrevision]]. Плагины обработки текста могут быть сколь угодно сложными, но это не влияет на производительность движка, так как обработка текста происходит один раз и ее результаты сохраняются.

event = oncomment
type = boolean

Вызывается в методе [[filtercomment]] фильтрации комментария, в качестве аргумента -текст комментария. Вызывается перед обработкой текста комментария, но после замены перевода строк и замены всех спецсимволов. Если последний обработчик события возвращает true, то последующей обработки не будет и будет вызвано событие [[onaftercomment]]. Пример использования, где слово home будет заменено адресом главной страницы сайта:
<code>
//подписываемся на событие
tcontentfilter::i()->oncomment =tmyclass::i()->filtercomment;
//наш класс
class tmyclass extends tplugin {
  public function filtercomment(&$s) {
    $s = str_replace('home', litepublisher::$site->url . '/', $s);
  }
}
</code>

event = onaftercomment

Вызывается после обработки текста комментария. Вы можете сделать изменения после всех фильтров в методе [[filtercomment]]

Пример использования, в конце комментария добавим параграф "Hello w World"":
<code>
//подписываемся на событие
tcontentfilter::i()->onaftercomment =tmyclass::i()->aftercomment;
//наш класс
class tmyclass extends tplugin {
  public function aftercomment(&$s) {
    $s .= "\n<p>Hello world</p>\n"; . $s;
  }
}
</code>

method = filtercomment
type = string

Вызывается из [[tcomments::add]] и [[tcomments::edit]]. Метод преобразует сырой текст комментария в конечный html, который будет использован при генерации списка комментариев на странице записи. Иными словами метод конвертирует $comment.rawcontent в $comment.content, и как раз тег $comment.content и используется в шаблоне комментария 
content.post.templatecomments.comments.comment

Вначале метод нормализует переводы строки заменяет все спецсимволы на html сущности. После чего вызывается событие [[beforecomment]], потом заменяются все bbcode, в зависимости от настроек создаются ссылки из текста. В конце вызывается событие [[aftercomment]]

method = filterpost

Центральный метод класса, который конвертирует сырой текст записи в законченный html записи, в том числе формируя анонс, ссылку далее и RSS. Этот метод вызывается из [[tpost::setcontent]], в случае если сырой текст не совпадает с новым текстом (это важное примечание, так как может оказаться, что новые фильтры не работают, тогда смотрите пояснения по номерам ревизии, которые решают эту проблему, в частности [[tposts::addrevision]]). Также этот метод вызывается из [[tpost::updatefiltered]], который просто перефильтроывает текст записи, например после увеличения номера ревизии записи.

И так метод вызван и предстоит сделать большую работу по конвертации текста. Первым делом вызывается событие [[beforecontent]], где один из 3 аргументов является переменная $cancel - флаг остановки. если в одном из обработчиков события [[beforecontent]] изменило $cancel на true, то дальнейшей фильтрации не будет происходить и будет вызвано событие [[aftercontent]]. Следовательно обработчик установивший $cancel в true, должен позаботится о заполнении свойств [[tpost::filtered]], [[tpost:;excerpt]], [[tpost::moretitle]], [[tpost::rss]] записи. Пример такой обработки плагин [[codedoc]]. Как правило обработка продолжается.

Следующий этап - разбиение текста записи на анонс, страницы. Вначале ищется тег <code><!--more--></code>, который позволяет разбить текст на анонс и полный текст. Полный текст разбивается на страницы методом [[ExtractPages]]. Чтобы текст записи имел несколько страниц его следует разграничить в тексте <code><!--nextpage--></code>. Если в текст не разграничен этим тегом, то запись не будет иметь текстовых страниц (может иметь страницы с комментариями). 

Если не был найден тег more разбивки на анонс и свойство [[automore]] = true, то будет создан автоматически анонс записи из полного текста длиной текста [[automorelength]] (учитывайте, что буквы русского языка в кодировке utf8 занимают два символа).

После извлечения или создания анонса ]]tpost::rss]] становится равным анонсу. Вы можете в записи имеет индивидуальный текст rss, отличающийся от анонса и полного текста.

Полный текст и анонс подвергается дополнительной фильтрации методом [[filter]], который вызывает свои события, на которые вам возможно надо будет подписаться.


В самом конце фильтрации, после всех фильтров вызывается событие [[aftercontent]] с единственным аргументом -$post.

event = beforecontent

Вызывается из [[filterpost]]. Важное примечание - запись может находится в процессе создания и $post->id = 0, а вам будет нужен id записи, то воспользуйтесь событием [[tpost::onid]], которое будет вызвано, когда у записи появится свой id. Это событие использует плагин [[wiki]] , который находит и заменяет все [[wiki]] слова. Событие как раз предназначено для предварительной фильтрации текста записи..

Пример использования, перед текстом добавим строку Hellow World:
<code>
//подписываемся на событие
tcontentfilter::i()->onaftersimple =tmyclass::i()->beforecontent;
//наш класс
class tmyclass extends tplugin {
    public function beforecontent(tpost $post, &$content, &$cancel) {
    $content  .= "\nHello world";
  }
}
</code>

Мы видим, что событие имеет 3 аргумента:

- $post - запись
- $content - сырой текст записи (вы его можете менять в обработчике)
- $cancel - по умолчанию = false, измените на true, чтобы метод [[filterpost]] не стал бы обрабатывать текст, разбивая его на анонс, фильтровать.

event = aftercontent

Вызывается из метода [[filterpost]] по окончанию фильтрации записи. Имеет всего один аргумент - $post запись. Событие предназначено действий после всех фильтров.

method = setexcerpt

Простой метод, который присваивает записи текст анонса,, ссылки далее. RSS устанавливается в анонс.

method = filter
type = string

Метод вызывается из [[filterpost]] и конвертирует строку. Первым делом вызывается событие [[beforefilter]], если последний обработчик события вернул true, то последующей обработки не происходит и будет вызвано событие [[afterfilter]] и возвращена строка. Далее если свойство [[usefilter]] = true, то будет произведена фильтрация, а иначе вызвано событие [[afterfilter]].

Если в тексте есть тег [_html_] (без подчеркивания), то текст будет разбит на кусочки и каждый кусочек будет отфильтрован отдельно методом [[simplefilter]]. Если тега для разбивки html не будет, то весь текст будет обработан методом [[simplefilter]]. Как писалось, в конце будет вызвано событие [[afterfilter]]

event = beforefilter

Вызывается из метода [[filter]] перед началом фильтрации с одним аргументом по ссылке - строкой для фильтрации. Пример использования, добавим в самое начало "Hello world":
<code>
//подписываемся на событие
tcontentfilter::i()->beforefilter =tmyclass::i()->beforefilter;
//наш класс
class tmyclass extends tplugin {
  public function beforefilter(&$s) {
    $s = "Hellow world\n" . $s;
  }
}
</code>

event = afterfilter

Вызывается из метода [[filter]] после фильтрации с одним аргументом по ссылке - строкой для фильтрации. событие симметрично событию [[beforefilter]].

method = simplefilter
type = string

Вызывается из метода [[filter]] для фильтрации участка текста. Вызывает событие [[onsimplefilter]], после чего делает замену тега code и конвертирует текст в ссылки, если свойство [[autolinks]]. Также расставляет параграфы в соответствии с переносом строк (метод [[auto_p]]). В конце вызывает событие [[onaftersimple]].

Следует объяснить, почему так много методов и событий фильтрации. Рассмотрим несколько случаев: 

1. в записи нет анонса, нет страниц, в настройках анонс не создается. Тогда все просто и каждый метод фильтрации и вызываемые ими события будут с одинаковым значением - полный текст записи. Расстановка тега p будет как раз в этом методе и получается, что настоящая фильтрация произойдет только в этом методе [[simplefilter]]
2. у записи есть анонс (не важно тегом more или автоматический). Будет дважды вызван метод [[filter]] с текстом анонса и полной записи.
3. В записи есть анонс и теги исключения html. Будет вызван метод [[filter]] для анонса и полного текста. В методе [[filter]] будет несколько раз вызван этот метод [[simplefilter]] для всех участков текста, чтобы не затронуть фильтрацией html. Но при этом будут вызваны события для всего анонса или полной записи в методе [[filter]].

Вывод - если нужно конвертировать исключительно текст, то используйте события [[onsimplefilter]] и [[onaftersimple]]. Пример таких плагинов - плагин внешних ссылок, markdown

event = onsimplefilter

Вызывается из метода [[simplefilter]] в самом начале метода. Параграфы в тексте события еще не расставлены. В методе будут расставлены параграфы. Пример использования, где перед текстом будет добавлена строка "Hello world":
<code>
//подписываемся на событие
tcontentfilter::i()->onsimplefilter =tmyclass::i()->beforesimple;
//наш класс
class tmyclass extends tplugin {
  public function beforesimple(&$s) {
    $s = "Hello world\n\n" . $s;
  }
}
</code>

event = onaftersimple

Вызывается из метода [[simplefilter]] уже самом конце метода. Параграфы в тексте события уже расставлены. Текст будет возвращен из метода. Пример использования, в конце строки добавим параграф:
<code>
//подписываемся на событие
tcontentfilter::i()->onaftersimple =tmyclass::i()->aftersimple;
//наш класс
class tmyclass extends tplugin {
  public function aftersimple(&$s) {
    $s .= "\n<p>Hello world</p>\n"; . $s;
  }
}
</code>

method = create
access = protected

Добавляет события и свойства в класс.

method = getpostdescription
type = string

Очищает строку дя использования в свойстве [[tpost:;description]], которое используется в секции head html страницы записи.

method = ExtractPages
type = string

Метод извлекает из строки страницы, если есть тег <code><!--nextpage--></code>. Если нет страниц, то возвращает отфильтрованную методом [[filter]] текст. Каждая извлеченная страница тоже отфильтровывается. Страница добавляется к страницам [[tpost::addpage]]. Возвращается текст первой отфильтрованной страницы.



method = gettitle
type =string

Метод очищает строку для заголовка страницы, удаляя пробельные символы и html теги.

method = splitfilter
type = string

Метод разбивает строку на части тегом [_html_] (без подчеркивания) и каждый кусок текста отфильтровывает методом [[simplefilter]], вызывается из [[filter]].


method = replacecode
type = string

Заменяет текст между html тегами code на спецсимволы. Зависит от свойства [[phpcode]].

method = getexcerpt
type = string

Очищает строку на заданный размер. Применяется для автоматического создания анонса в тексте записи.


method = ValidateEmail
type = boolean

Статический метод, который регулярным выражением проверяет правильность email адреса. Пример использования

if (tcontentfilter::ValidateEmail("nick@some.com")) echo "E-Mail valid";

method = quote
type = string

Статический метод который заменяет символы ', ", %, _, $ на html сущности.

method = escape
type = string

Статический метод, который очищает строку, удаляя теги и заменяя спецсимволы на html сущности.


method = getidtag
type = string

Статический метод, который пытается извлечь значение id из исходного html с указанным тегом. Редко применяется.

method = bbcode2tag
type = string

Статический метод, который заменяет исходный bbcode на указанный html

method = simplebbcode
type = string

Статический метод, который заменяет bbcode B, I, code, quote на соответствующий html.


method = auto_p
type = string

Статический метод, который автоматически расставляет тег p и br в соответствии с переносами в исходном тексте. Учитываются уже существующие html теги. На настоящее время этот метод претерпел значительную эволюцию, но в некоторых спорных местах может проставить лишние теги p. Чтобы полностью исключить такую возможность при фильтрации текста используйте специальный тег для вставки нефильтрованного html


method = createlinks
type = string

Статический метод, который преобразует текстовые ссылки в кликабильные html ссылки.

prop = automore
type = boolean
access = rw

Свойство определяет создавать ли автоматически анонс, если отсутствует тег more в исходном тексте. true - создавать. Его можно изменить в админке на странице Настройки/Вид

prop = automorelength
type = integer
access = rw

Количество символов в автоматически созданном анонсе. Обратите внимание, что русские буквы в кодировке utf8 занимают два символа. Его можно изменить в админке на странице Настройки/Вид

prop = phpcode
type = boolean
access = rw

Свойство отвечает, будет ли PHP код в тексте будет преобразован к html тегу code, или оставлен как есть и следовательно будет исполнен. Его можно изменить в админке на странице Настройки/Безопасность
prop = usefilter
type = boolean
access = rw

Свойство отвечает будет ли использован фильтр текста или нет. Если вы не хотите, чтобы фильтры расставляли тег p и br для переводов строк, то измените на false. Его можно изменить в админке на странице Настройки/Вид

prop = autolinks
type = boolean
access = rw

Свойство отвечает за автоматическое создание ссылок из текста. Его можно изменить в админке на странице Настройки/Вид

prop = commentautolinks
type = boolean
access = rw

Свойство отвечает за автоматическое создание ссылок из текста комментариев. Его можно изменить в админке на странице Настройки/Вид
