classname = tcontentfilter
parent = tevents

Специальный класс для конвертирования текста в html в записях и комментариях. LitePublisher устроен таким образом, что хранит исходный текст и отфильтрованный конечный html записей, комментариев, меню. Преобразование между исходным текстом и конечным html как раз делает этот класс. Соответственно очень много плагинов встраиваются в цепочки таких фильтров, например markdown, wiki, система документации, плеер youtube, короткие коды, внешние ссылки, tidy и так далее. Все эти плагины подписываются (другими словами обрабатывают) события этого класса. Фильтрация текста как правило происходит один раз (или после изменения исходного текста) и ее результаты используются. Чтобы перефильтровать все записи  (например при инсталяции плагина внешних ссылок) есть специальный механизм litepublisher - номер ревизии, смотрите [[tposts::addrevision]]. Плагины обработки текста могут быть сколь угодно сложными, но это не влияет на производительность движка, так как обработка текста происходит один раз и ее результаты сохраняются.

event = oncomment
type = boolean

Вызывается в методе [[filtercomment]] фильтрации комментария, в качестве аргумента -текст комментария. Вызывается перед обработкой текста комментария, но после замены перевода строк и замены всех спецсимволов. Если последний обработчик события возвращает true, то последдующей обработки не будет и будет вызвано событие [[onaftercomment]]. Пример использования, где слово home будет заменено адресом главной страницы сайта:
<code>
//подписываемся на событие
tcontentfilter::i()->oncomment =tmyclass::i()->filtercomment;
//наш класс
class tmyclass extends tplugin {
  public function filtercomment(&$s) {
    $s = str_replace('home', litepublisher::$site->url . '/', $s);
  }
}
</code>

event = onaftercomment

Вызывается после обработки текста комментария. Вы можете сделать изменения после всех фильтров в методе [[filtercomment]]

Пример использования, в конце комментария добавим параграф "Hellow World"":
<code>
//подписываемся на событие
tcontentfilter::i()->onaftercomment =tmyclass::i()->aftercomment;
//наш класс
class tmyclass extends tplugin {
  public function aftercomment(&$s) {
    $s .= "\n<p>Hello world</p>\n"; . $s;
  }
}
</code>

method = filtercomment
type = string

Вызывается из [[tcomments::add]] и [[tcomments::edit]]. Метод преобразует сырой текст комментария в конечный html, который будет использован при генерации списка комментариев на странице записи. Иными словами метод конвертирует $comment.rawcontent в $comment.content, и как раз тег $comment.content и используется в шаблоне комментария 
content.post.templatecomments.comments.comment

Вначале метод нормализует переводыстроки заменяет все спецсимволы на html сущности. После чего вызывается событие [[beforecomment]], потом заменяются все bbcode, в зависимости от настроек создаются ссылки из текста. В конце вызывается событие [[aftercomment]]

method = filterpost

Центральный метод класса, который конвертирует сырой текст записи в законченный html записи, в том числе формируя анонс, сылку далее и RSS. Этот метод вызывается из [[tpost::setcontent]], в случае если сырой текст не совпадает с новым текстом (это важное примечание, так какможет оказаться, что новые фильтры не рабтают, тогда смотрите пояснения по номерам ревизии, которые решают эту проблему, в частности [[tposts::addrevision]]). Также этот метод вызывается из [[tpost::updatefiltered]], который просто перефильтроывает текст записи, например после увеличения номера ревизии записи.

И так метод вызван и предстоит сделать большую работу по конвертации текста. Первым делом вызывается событие [[beforecontent]], где один из 3 аргументов является переменная $cancel - флаг остановки. если в одном из обработчиков события [[beforecontent]] изменило $cancel на true, то дальнейшей фильтрации не будет происходить и будет вызывано событие [[aftercontent]]. Следовательно обработчик установивший $cancel в true, должен позаботится озаполнении свойств [[tpost::filtered]], [[tpost:;excerpt]], [[tpost::moretitle]], [[tpost::rss]] записи. Пример такой обработки плагин [[codedoc]]. Как правило обработка продолжается.

Следующий этап - разбиение текста записи на анонс, страницы. Вначале ищется тег <code><!--more--></code>, который позволяет разбить текст на анонс и полный текст. Полный текст разбивается на страницы методом [[ExtractPages]]. Чтобы текст записи имел несколько страниц его следует разграничить в тексте <code><!--nextpage--></code>. Если в текст не разграничен этим тегом, то запись не будет иметь текстовых страниц (может иметь страницы с комментариями). 

Если не был найден тег more разбивки на анонс и свойство [[automore]] = true, то будет создан автоматически анонс записи из полного текста длиной текста [[automorelength]] (учитывайте, что буквы русского языка в кодировке utf8 занимают два символа).

После извлечения или создания анонса ]]tpost::rss]] становится равным анонсу. Вы можете в записи имет индивидуальный текст rss, отличающися от анонса и полного текста.

Полный текст и анонс подвергается дополнительной фильтрации методом [[filter]], который вызыает свои события, на которые вамвозможно надо будет подписаться.


В самом конце фильтрации, после всех фильтров вызывается событие [[aftercontent]] с единственным аргументом -$post.

event = beforecontent

Вызывается из [[filterpost]] и имеет3 аргумента, вот пример обработчика
  public function my_before_content(tpost $post, &$content, &$cancel) { ...}
где соответствено $post - запись, $content - сырой текст записи (вы его можете менять в обработчике), $cancel - по умолчанию = false, если вы измените на true, то метод [[filterpost]] не будет обрабатывать текст на  и прочее.анонс. Важное примечание - запись может находится в процессе создания и $post->id = 0, а вам будет нужен id записи, то воспользуйтесь событием [[tpost::onid]], которое будет вызвано, когда у записи появится свой id. Это событие использует плагин [[wiki]] , который находит и заменяет все [[wiki]] слова. Событие как раз предназначено для предварительной фильтрации текста записи..

event = aftercontent

Вызывается из метода [[filterpost]] по окончанию фильтрации записи. Имеет всего один аргумент - $post запись. Событие предназначено действий после всех фильтров.


method = setexcerpt

Простой метод, который присваивает записи текст анонса,, ссылки далее. RSS устанавливается в анонс.

method = filter
type = string

Метод вызывается из [[filterpost]] и конвертирует строку. Первым делом вызвается событие [[beforefilter]], если последний обработчик события вернул true, то последующей обработки не происходит и будет вызвано событие [[afterfilter]] и возвращена строка. Далее если свойство [[usefilter]] = true, то будет произвидена фильтрация, а иначе вызывано событие [[afterfilter]].

Если в тексте есть тег [_html_] (без подчеркивания), то текст будет разбит на кусочки и каждый кусочек будет отфильтрованотдельно методом [[simplefilter]]. Если тега для разбивки html не будет, то весь текст будет обработан методом [[simplefilter]]. Как писалось, в конце будет вызвано событие [[afterfilter]]

event = beforefilter

Вызывается из метода [[filter]] перед началом фильтрации с одним аргументом по ссылке - строкой для фильтрации.

event = afterfilter

Вызывается из метода [[filter]] после фильтрации с одним аргументом по ссылке - строкой для фильтрации.

method = simplefilter
type = string

Вызывается из метода [[filter]] для фильтрации участка текста.  Вызывает событие [[onsimplefilter]], после чего делает замену тега code и конвертирует текст в ссылки, если свойство [[autolinks]]. Также расставляет параграфы в соответствии с переносом строк (метод [[auto_p]]). В конце вызывает событие [[onaftersimple]].

Следует объяснить, почему так много методов и событий фильтрации. Рассмотрим несколько случаев: 

1. в записи нет анонса, нет страниц, в настройках анонс не создается. Тогда все просто и каждый метод фильтрации и вызываемые ими события будут с одинаковым значением - полный текст записи. Расстановка тега p будет как раз в этом методе и получается, что настоящая фильтрация произойдет только в этом методе [[simplefilter]]
2. у записи есть анонс (не важно тегом more или автоматический). Будет дважды вызван метод [[filter]] с текстом анонса и полной записи.
3. В записи есть анонс и теги исключения html. Будет вызван метод [[filter]] для анонса и полного текста. В методе [[filter]] будет несколько раз вызван этот метод [[simplefilter]] для всех участков текста, чтобы не затронуть фильтрацией html. Но при этом будут вызываны события для всего анонса или полной записи в методе [[filter]].

Вывод - если нужно конвертировать исключительно текст, то используйте события [[onsimplefilter]] и [[onaftersimple]]. Пример таких плагинов - плагин внешних ссылок, markdown

event = onsimplefilter

Вызывается из метода [[simplefilter]] в самом начале метода. Параграфы в тексте события еще не расставлены. В методе будутрасставлены параграфы. Пример использования, где перед текстом будет добавлена строка "Hello world":
<code>
//подписываемся на событие
tcontentfilter::i()->onsimplefilter =tmyclass::i()->beforesimple;
//наш класс
class tmyclass extends tplugin {
  public function beforesimple(&$s) {
    $s = "Hello world\n\n" . $s;
  }
}
</code>

event = onaftersimple

Вызывается из метода [[simplefilter]] уже самом конце метода. Параграфы в тексте события уже расставлены. Текст будет возвращен из метода. Пример использования, в конце строки добавим параграф:
<code>
//подписываемся на событие
tcontentfilter::i()->onaftersimple =tmyclass::i()->aftersimple;
//наш класс
class tmyclass extends tplugin {
  public function aftersimple(&$s) {
    $s .= "\n<p>Hello world</p>\n"; . $s;
  }
}
</code>
