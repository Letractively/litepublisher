* Lite Publisher
* Copyright (C) 2010 Vladimir Yushko http://litepublisher.com/
* Dual licensed under the MIT (mit.txt)
* and GPL (gpl.txt) licenses.

 ФАЙЛ ТЕМЫ ДЛЯ CMS LitePublisher (другое название движка Блоголёт). В этом файле описываются и устанавливаются все шаблоны темы. Тема представляет собой набор вложенных друг в друга шаблонов, таким образом получается дерево шаблонов. Каждый из шаблонов - это готовый HTML с тегами Litepublisher. Теги  LitePUblisher - это выражения вида $object.property, где object - обект, а property - его свойство. Например $template.title или $template.content. Со списком всех доступных тегов вы можете ознакомится в документации.

О формате этого файла. В файле находятся обявления тегов и комментарии. Комментарии возможны только вне обявлений тегов и невозможны внутри тегов. Объявление тега выглядит следующим образом: $template.name =[ html тега $template.name] Перед $template могут быть только пробелы или строка сразу должна начинатся с $tempalte., иначе строка пропускается как комментарий.Для всех тегов можно опускать $template. для сокращения имени тега. Вместо квадратных скобок [] могут использоваться либо круглые ()ЛИБО ФИГУРНЫЕ{}скобки. Выбирать можно любые парные скобки, единственное условие - чтобы в тексте шаблона все открытые скобки закрывались. То есть если вы выбрали [], то текст шаблона должен закрыть все открытые в нем квадратные скобки.

На верхнем уровне иерархии шаблонов находятся всего несколько шаблонов:
$template - шаблон всей страницы целиком
$template.title - шаблон заголовка страницы
$template.menu - список страниц меню
$template.content - содержание, содержит все основные шаблоны
$template.sitebar - шаблон сайтбара и виджетов в нем

Начнем декларировать шаблоны верхнего уровня, и в начале обявим шаблон всей страницы целиком:

$template = {@import(main.htm)}

Это обявление означает, что шаблон находится в файле  main.htm - посмотрите его в той же папке, что и этот файл. Включать шаблон из файла можно двумя способами - как в этом примере @import(имя файла с шаблоном), и второй способ file=имя файла. Во втором случае обявление шаблона выглядело бы как $template = {file=main.htm} Какой способ выбрать остается на ваше усмотрение. Включаемые файлы могут находится только в папке темы и нигде больше.

Давайте откроем файл main.htm и посмотрим его содержимое - в нем находится шаблон всей страницы полностью. Следует заметить, что вэтом шаблоне отсутствуют какие либо вложенные шаблоны. Сделано это специально для демонстрации общей структуры темы на самом верхнем уровне. Можно немного поподробнее остановиться на каждом из тегов. Самым первым встречается тег $template.title - заголовок страницы. Установим шаблон для заголовка страницы следующим образом:

$template.title = [$title | $site.name]

где $title - это например заголовок записи, а $site.name - название сайта в настройках. Мы уже объявили два шаблона в теме - 	$template(шаблон всей страницы) и $template.title (заголовок страницы). Далее встречаются следующие теги, которые не являются шаблонами:
$template.url - адрес этой темы, используется чтобы указать адрес файлов темы. Нигде не декларируется, так как это не шаблон.
$template.head - стандартный html для секции HEAD HTML документа.
$site.url - адрес сайта
$site.name - название сайта
$site.description - описание сайта

Далее мы встречаем тег $template.menu - ЭТО СПИСОК МЕНЮ В ШАПКЕ САЙТА, ЗАДЕКЛАРИРУЕМ ШАБЛОН ДЛЯ ЭТОГО ТЕГА

$TEMPLATE.MENU = [
$hover = [true]
	<ul id="nav">
		$item = [<li><a href="$link" title="$title">$title</a>$submenu = [ <ul>$items</ul>]</li>]
		$current = [		<li class="current_page_item"><a href="$link" title="$title">$title</a>$submenu</li>]
	</ul>
]

В этом шаблоне мы встретили два вложенных шаблона: $item и $current, а шаблон $item имеет у себя вложенный шаблон  $submenu. Что же означают эти шаблоны? $item ОТВЕЧАЕТ ЗА элемент списка меню, $current отвечает за текущий элемент списка - когда ёоткрытая страница это меню, то эта ссылка может быть выделена. Вложенный в $item, шаблон $submenu отвечает за шаблон подменю - имеет смысл для тем поддерживающих всплывающее меню. Далее шаблон меню использует для генерации html списка меню следующие значения:

$link - адрес страницы, включая адрес сайта
$url - адрес страницы меню, без адреса сайта
$TITLE - ЗАГОЛОВОК МЕНЮ
$ITEMS - ИСПОЛЬЗУЕТСЯ В ШАБЛОНЕ ПОДМЕНЮ $SUBMENU, КОТОРОЕ ГЕНЕРИРУЕТСЯ движком.

Для того, чтобы указать, что тема не поддерживает всплывающее меню следует первой строкой в шаблоне меню поставить следующий html комментарий:
<!--nohover-->

Про меню все. Перейдем к  следующему очень важному тегу - $template.content. В нем содержатся шаблоны контента сайта. Перечислим эти шаблоны:
simple - шаблон для простых текстов, не имеет вложенных шаблонов и состоит из одной - двух строк
menu - шаблон страницы меню, не имеет вложенных шаблонов
notfound - шаблон для страницы 404, не  имеет вложеных шаблонов
excerpts - шаблон для анонсов, включает в себя вложенные шаблоны
post - шаблон полной записи, включает в себя много шаблонов, в том числе комментарии и форму комментариев
navi  - шаблон ссылок для постраничной навигации, имеет вложенные шаблоны
admin - шаблоны для админки, имеет вложенные шаблоны

Перейдем к заданию шаблонов контента. Начнем с простого - шаблон simple, который отвечает за вывод простого контента

	$template.content.simple = [
			<div class="simplecontent">$content</div>
]

Видим, что в этом шаблоне есть только одна переменная $content - в ней находится текст. Обявим еще один простой шаблон для страницы 404:

$template.content.notfound = [
			<div class="simplecontent">
				<h2 class="center">$lang.notfound </h2>
				<p class="center">$lang.nocontent</p>
]

Здесь мы видим использование двух тегов $lang.notfound и $lang.nocontent - эти значения берутся из языковых файлов lib/languages/*.ini, $lang.* всегда доступны в любом шаблоне и позволяют теме быть интернациональной.

 Перейдем к относительно более сложному шаблону - страница меню, и можем опустить употребление $template. Обявление content.menu = [ и обявление $template.content.menu = [ абсолютно равнозначны, единственный смысл опускать $template лишь в сокращении записи. Пропускание $template не избавлляет от испобьзования символа $ во вложенных шаблонах.

content.menu = [
			<div class="post" id="menu-$menu.id">
		        <h2>$menu.title</h2>
		        <div class="post-content">
					$menu.content
		        </div>
			</div>
]

В этом шаблоне мы видим использование теговдля меню $menu.*, а именно
$menu.id - уникальный id (число) меню
$menu.title - заголовок меню
$menu.content - текст страницы меню
у $menu есть и другие свойства, которые не использовались в этом шаблоне, например $menu.url, $menu.parent

Теперь можно переходить к более сложным шаблонам, каковым является шаблон записи. Можно объявить этот шаблон целиком со всеми вложенными шаблонами (формат файла темы это позволяет), но тогда будет сложнее комментировать каждый из шаблонов, поэтому постараемся обойтись минимумом вложенных шаблонов. Начнем:

content.post = [
			<div class="post" id="post-$post.id">
		        <h2><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.iconlink$post.title</a></h2>
					<span class="post-date">$post.date</span>
					<span class="post-tags">$post.taglinks</span>
						<div class="post-content">
       $post.filelist
							$post.content
							<div class="post-info">
								$post.rsslink
								<span class="post-cat">$post.catlinks</span>	
							</div>
							$post.prevnext
						</div>
      $post.templatecomments
			</div>
]

Таким образом мы смогли обявить шаблон для записи обойдясь вообще без вложенных шаблонов. В шаблоне записи используется свойства обекта $post, рассмотрим их:

$post.id - уникальный id (число) записи
$post.link- полный адрес записи, включая адрес сайта
$lang.permalink - переведенная строка "постоянная ссылка на"
$post.title - заголовок записи
$post.iconlink - html ссылка на иконку, если есть
$post.date - отформатированная и переведенная дата публикации поста. о формате и шаблоне даты читайте ниже
$post.taglinks - ссылки на метки записи, для них есть свой шаблон
$post.filelist - список файлов записи, длясписка есть свой шаблон
$post.content - текст записи
$post.catlinks - ссылки на рубрики записи, тоже можно задать шаблон
$post.rsslink - html ссылка на rss комментариев к записи, есть для этого тоже шаблон				$post.prevnext - ссылки на следующую и предыдущую запись, можно задать для этих ссылок шаблон
$post.templatecomments - выводит список комментариев и форму для отправки комментария. имеет много вложенных шаблонов.

Дополнительно приведу еще список тегов записи, могущих оказаться полезными при разработке темы:
$post.day - день (01-31) публикации
$post.month - месяц, краткое название (Несколько букв)
$post.year - год публикации, 4 цифры
$post.bookmark - html ссылка на запись, для этого внутри движка используется шаблон:
 <a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.iconlink$post.title</a>

$post.pubdate - дата публиккации в формате пригодным для RSS
$post.excerptdate - отформатированная дата публикации для анонса. Про дополнительные тегидля анонсов будет рассказано когда будем рассматривать шаблоны для анонса.
$post.morelink - ссылка "Далее" в анонсе
$post.tagnames - метки, перечисленные через запятую, без ссылок, только названия
$post.catnames -рубрики, перечисленные через запятую, без ссылок, только названия
$post.head - html для секции head
$post.keywords - ключевые слова, по умолчанию равны меткам
$post.description - описание записи, по умолчанию это обрезанный анонс
$post.moretitle - текст для ссылки "Далее"
$post.title2 - аальтернативный заголовок записи, обычно это пустая строка
$post.rss - текст записи в ленте RSS
$post.commentscount - количество комментариев к записи
$post.commentslink - html ссылка на комментарии к записи
$post.iconurl - адрес иконки, если она есть

Получился обширный список тегов, которые вы можете использовать в шаблоне записи. Некоторым из тегов записи вы можете задать свои шаблоны, а именно вот этим:

$post.date - отформатированная и переведенная дата публикации поста
$post.filelist - список файлов записи, длясписка есть свой шаблон
$post.taglinks - ссылки на метки записи
$post.catlinks - ссылки на рубрики записи
$post.more - шаблон для внутристраничной ссылки из анонса, то есть куда ссылается ссылка "Далее" из анонса
$post.rsslink - ссылка на rss комментариев к записи
$post.prevnext - ссылки на следующую и предыдущую запись
$post.templatecomments - выводит список комментариев и форму для отправки комментария. имеет много вложенных шаблонов.

Теперь можно задать детальные шаблоны для каждого из приведенных в списке тегов, в конце рассмотрим шаблон комментариев, как самый сложный. Начнем по порядку - с шаблона формата даты публикации

content.post.date = [d.m.Y]

Как видим формат простой - это параметры для php функции date, и вданном случае это d.m.Y, дата будет переведена на язык сайта. Следующим тегом идет $post.taglinks, зададим шаблон для списка меток

content.post.taglinks = [
							$lang.tags: 
								$item = [ <a href="$link" title="$title">$icon$title</a>]
								$divider = [, ]
]

Шаблон получился не сложным, в нем присутствует строка $lang.tags - "Метки", а также два вложенных шаблона:
$ITEM - ШАБЛОН ОДНОЙ МЕТКИ
$divider - шаблон разделителя ссылок

 Все. Симметрично устроен шаблон для рубрик. Объявим его

content.post.catlinks = [
							$lang.categories: 
								$item = [ <a href="$link" title="$title">$icon$title</a>]
								$divider = [, ]
]

Вся разница между двумя этими шаблонами в $lang - в первом случае это "Метки", а во втором - "Рубрики".Для каждой метки и рубрики в шаблоне $item доступны следующие теги:

$id - уникальный id метки или рубрики
$link - адрес, включает адрес сайта
$url - адрес без адреса сайта
$title - название (заголовок) метки или рубрики
$itemscount - количество записей в метке или рубрике
$parent = уникальный id родительской метки или рубрики, имеет смысл при вложенных метакх и рубриках
$icon - html иконки, если есть

Перед тем, как расматривать шаблон списка файлов рассмотрим два несложных шаблона - ссылка на RSS и ссылки на следующую и предыдущую запись.

CONTENT.post.rsslink = [
<span class="post-rsscomments"><a href="$post.rsscomments" title="$lang.subscribetorsscomments" >$lang.subscribetorsscomments</a></span>
]

В этом шаблоне встречаются два тега: $post.rsscomments - это адресс ссылки RSS комментариев записи, а $lang - строка "Подписаться на RSS комментариев". Все более чем просто. Также несложный шаблон ссыллок на следующую и предыдущую запись:

CONTENT.POST.PREVNEXT = [
								<div id="prevnext">
								$prev = [<p id="prev">&larr; $lang.prev <a rel="prev" href="$prevpost.link" title="$lang.permalink $prevpost.title">$prevpost.title</a></p>]
								$next = [<p id="next">$lang.next <a rel="next" href="$nextpost.link" title="$lang.permalink $nextpost.title">$nextpost.title</a> &rarr;</p>]
								</div>
]

В шаблоне есть всего два вложенных шаблона:
$prev - шаблон ссылки на предыдущую запись
$next - шаблон ссылки на следующую запись

В каждом из этих двух шаблонов доступны (и вобщем шаблоне) теги 

$prevpost - предыдущая запись
$nextpost - следующая запись

Разрешено использовать любые теги для записи, здесь же использовались уже ранее встречавшиеся свойства записи link  и title. Перейдем к более сложному и важному шаблону - шаблон списка файлов.

content.post.filelist = [
								<ul id="files-$post.id">

  $file = [<li><a href="$site.files/files/$filename" title="$title">$description</a></li>]

  $image = <li><a rel="gale-$post.id" onclick="return jsiBoxOpen(this)" href="$site.files/files/$filename" title="$title">$preview$title</a></li>]

  $preview = [<img src="$site.files/files/$preview.filename" title="$title" alt="$title" />]

   $audio = [<li><a href="$site.files/files/$filename" title="$title">$title</a>
								<span id="audiofile-$id"><a onclick="playaudiofile('audiofile-$id', '$site.files/files/$filename');" title="$title">$lang.play</a></span></li>]

   $video = [<li><a href="$site.files/files/$filename" title="$title" id="videofile-$id">$title</a>
<a onclick="playvideofile('videofile-$id', '$site.files/files/$filename');" title="$title">$lang.play</a></li>]

								</ul>
]

Мы видим обявление в списке файлов шаблоны для разных типов. Несложно догадатся, какой шаблон отвечает за какой тип файлов

$file - отсутствует тип файла, скорее всего это бинарник
$image - картинка, по умолчанию к картинкам создаются миниатюры. Этот шаблон для картинок сразу организует их в галерею
$preview - шаблон для миниатюр, они используются в галереи
$audio - шаблон для аудиофайлов, этот шаблон включает плеер только по клику по ссылке "Воспроизвести"
$video - шаблон для видеороликов. Видеоплеер будет загружен по клику на ссылку "Воспроизвести"

LitePublisher генерирует список файлов на основе этих шаблонов, файлы сортируются по типам. Внутри шаблона длялюбого типа файла доступны свойства файла, а именно:
$id - уникальный id файла (число)
$media - тип файла, строка имеет одно из следующих значений: 'bin','image','icon','audio','video','document','executable','text','archive'
$parent - уникальный id родительского файла, в шаблонах = 0, кроме шаблона для миниатюр - $preview
$preview - уникальный id миниатюры, если миниатюры нет, то равен 0. Имеет смысл только для картинок
$icon - уникальный id иконки для этого типа файлов. В настоящее время не используется и равно 0.
$author - уникальный id автора файла. Имеет смысл при многопользовательском режиме.
$size - размер в байтах файла
$posted - дата добавления файла
$mime - mime тип файла, строка, не всегда возможно коректное значение
$filename - имя файла, включая папку относительно общей папки файлов. Полный адрес к файлу получается $site.files$filename
$title - название файла, если не было задано, то равно имени файла
$description - описание файла, пустая строка, если не задано 
$keywords - ключевые слова для файла, пустая строка, если не задано
$md5 - строка равна хешу md5 файла (32 букв и цифр), используется для фильтрации копий файлов, в шаблонах не используется
$height - высота картинки, для других типов файлов = 0
$width - ширина картинки, для других типов файлов = 0
$bitrate - не используется, равно 0
$framerate - не используется, равно 0
$samplingrate - не используется, равно 0
$channels - не используется, равно 0
$duration - не используется, равно 0

Вы можете использовать любую комбинацию этих значений в шаблоне файлов. Следует заметить, что в шаблонах файлов изпользуются javascript, которые являются частью движка LitePublisher, но если вы желаете, то можете указать любые другие javascript (не забыв их включить в секции head). Однако следует заметить, что javascript LitePublisher работают таким образом, что они используют мало ресурсов - плееры подгружаются только по клику на ссылку "Воспроизвести" и поэтому страница открывается очень быстро. Для многих список файлов в теме является очень важным вопросом, поэтому за дополнительной информацией обращайтес в тикет систему по адресу:
http://litepublisher.ru/

После шаблонов списка файлов переходим к шаблону списка комментариев  content.post.templatecomments, который включает в себя множество шаблонов, а именно:

$closed - шаблон сообщения о закрытом комментировании
$form - форма отправки комментария
$confirmform - форма подтверждения комментария
$moderateform - форма для модерирования
$comments - шаблон списка комментариев
$pingbacks - список пингбеков

Будем разбирать каждый из этих шаблонов по нарастанию сложности. Самый простой шаблон - сообщение закрыто:

content.post.templatecomments.closed = [<p class="nocomments">$lang.closed</p>]

Внутри шаблона встречается тег $lang.closed - строка "Комментирование закрыто". Далее посмотрим на шаблонформы комментирования - в зависимости от настроек записи будет выдаваться сообщение о закрытом комментировании либо форма отправки. Объявим:

content.post.templatecomments.form = [
								<p id="respond">$lang.leavereply</p>
								<form action="$options.url/send-comment.php" method="post" id="commentform">
									<p><input type="text" name="name" id="name" value="$name" size="22" tabindex="1" />
									<label for="name">$lang.name</label></p>

									<p><input type="text" name="email" id="email" value="$email" size="22" tabindex="2" />
									<label for="email">$lang.email</label></p>

									<p><input type="text" name="url" id="url" value="$url" size="22" tabindex="3" />
									<label for="url">$lang.url</label></p>

									<p><input type="checkbox" name="subscribe" id="subscribe" $subscribe size="22" tabindex="4" />
									<label for="subscribe">$lang.subscribe</label></p>

									<p><textarea name="content" id="comment" rows="10" cols="60%" tabindex="5"></textarea></p>

									<input type="hidden" name="postid" value="$postid" />
									<input type="hidden" name="antispam" value="$antispam" />

									<p><input name="submit" type="submit" id="submit" tabindex="6" value="$lang.send" /></p>
								</form>
]

Шаблон не смотря на свой объем является простым, так как не включает в себя вложенных шаблонов. В шаблоне формы использовались следующие теги:

$name - имя комментатора
$email - E-Mail комментатора
$url - адрес сайта комментатора
$subscribe - подписка по E-Mail, пустая строка либо checked="checked"
$content - текст комментария
$postid - уникальный id записи к которой отправляется комментарий
$antispam - строка созданная движком для защиты от спама

Если комментатор первый раз оставляет комментарий, то $name, $email, $url являются пустыми строками, а если комментатор уже отправлял свой комментарий, то они заполняются соответствующими значениями. Особняком стоит значение $subscribe - подписка на E-Mail новых комментариев: для первый раз комментирующего это значение выставляется в зависимости от настроек сайта, для повторного комментатора в том значении, в котором он последний раз комментировал.

Следующей после отправки комментария находится форма подтверждения оного. Зададим шаблон для формы подтверждения:

content.post.templatecomments.confirmform = [
								<h2>$lang.formhead</h2>
								<form name="preform" method="post" action="">
								  <p><input type="submit" name="submit1" value="$lang.robot"/></p>
								</form>

								<form name="form" method="post" action="">
								<input type="hidden" name="confirmid" value="$confirmid" />
								  <p><input type="submit" name="submit2" value="$lang.human"/></p>
								</form>
]

Как видим этот шаблон состоит из двух форм - ложной формы для роботов и форма для людей. В форме для людей находится  один шаблон:
$confirmid - строка с набором цифр и букв для подтверждения комментария. Для каждого комментария генерируется случайно своя собственная строка, эту комбинацию невозможно угадать и она становится известной только после заполнения формы отправки комментария. Такая простая защита значительно отсеивает спам и позволяет людям спокойно отправлять комментарии.

К простым шаблонам также относится и шаблон кнопок модерирвания для массовой модерации, не индввидуальные кнопки в каждом комментарии, а общие кнопки для всего списка. Присвоим шаблон

content.post.templatecomments.moderateform= [
								<form name="moderateform" action="$options.url/admin/comments/" method="post">
								$comments
								<p>
								<input type="button" name="approvebutton" value="$lang.approve" onclick="submitmoderateform(this.form, 'approved');" />
								<input type="button" name="deletebutton" value="$lang.delete" onclick="submitmoderateform(this.form, 'delete');" />
								<input type="button" name="holdbutton" value="$lang.holdbutton" onclick="submitmoderateform(this.form, 'hold');" />
								<input type="button" value="$lang.sendreply" onclick="sendreply();" />
								</p>
								</form>
]

Этот шаблон привязан к javascript LitePublisher - модерация комментариев происходит без перезагрузки страницы. Следует обратить внимание на обязательный тег $comments - это список комментариев. Получается, что этот список находится внутри формы - это нужно потому, что у каждого комментария есть чекбокс, которые обрабатываются javascript. Форма модерирования и чекбоксы появляются только для залогиненного модератора. $lang.* - строки, названия кнопок.

Перейдем к главному - список комментариев и сам шаблон комментария. Шаблон списка включает в себя следующие шаблоны:

$count - шаблон количества комментариев на запись
$hold - шаблон заголовка для задержанных комменттариев
$comment - шаблон комментария

Начнем обявлять шаблоны:

content.post.templatecomments.comments.count = [
<p id="comments">$count $lang.topost &#8220;$post.title&#8221;</p>
]

В шаблоне количества комментариев нам доступны следующие теги:

$post.* - все свойства записи $post, здесь использовали title -заголовок записи
$count - собствено число комментариев, уже отформатированое для языка (0 = нет комментариев, 1 = 1 комментарий, и так далее)
$lang.topost - строка "на запись"

Вот простой шаблон для заголовка задержанных комментариев:
content.post.templatecomments.comments.hold = [<p class="hold"><em>$lang.hold</em></p>]

А вот и сам список комментариев:

content.post.templatecomments.comments = [
  <a name="comments"></a>
  <ol class="commentlist" id="$commentsid=[commentlist]" start="$from">
$items
										</ol>
]
